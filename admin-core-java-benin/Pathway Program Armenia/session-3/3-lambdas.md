---
author: Vahe Pezeshkian
title: Java (II) - Lambdas
institute: Sourcemind
theme: default
---

# Anonymous classes

- Compile the following source code
- We could define a class that implements the `Runnable` interface but we chose to implement it at the point we want to use it
- We don't have an explicit **reference** to it

```java
public class AnonymousTest {
    public static void main(String[] args) {
        Comparator<Shape> myComparator = new Comparator<Shape>() {
            @Override
            public int compare(Shape o1, Shape o2) {
                return (int) (o1.calculateArea() - o2.calculateArea());
            }
        };


        myComparator.compare(/* two shapes */);
    }
}
```

- View the generated class files
	- Text mode
	- Using `javap -c AnonymousTest.class`

# Functional interfaces

- Optionally marked as `@FunctionalInterface`
- A functional interfaces must have a **single abstract method** (SAM)
- Comparator: `compare(T obj1, T obj2);`
- Runnable: `run();`
- Functional interfaces can be written as **lambdas**
	- Functional style programming
	- Less verbose

```java
Runnable job = () -> System.out.println("Running a job");
job.run();

List<String> list = new ArrayList<>();
list.add("a"); list.add("abc"); list.add("xy");
list.sort((o1, o2) -> o1.length() - o2.length());
System.out.println(list);

// Or

Comparator<String> stringComparator = 
	(o1, o2) -> o1.length() - o2.length();
list.sort(stringComparator);
```

- Examine the generated bytecode
- There are no generated classes

```
0: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;
5: astore_1
6: aload_1
7: invokeinterface #3,  1            // InterfaceMethod java/lang/Runnable.run:()V
```

# Functional interface types

- Function: accept something(s), return something
- Predicate: accept something(s), return a true / false
- Consumer: accept something(s), return nothing but do something with the value(s)
- Supplier: accept nothing, return a value

```java
abstract class Shape {
	private double area;
	public abstract double calculateArea();
}

Function<Shape, Double> areaCalculatorLambda = (shape) -> shape.calculateArea();

// Or, using Method Reference
Function<Shape, Double> areaCalculatorLambda = Shape::calculateArea;
```

# Functional programming with Java

- Java 8 introduced Stream API
- Similar to 

```java
File file = new File("Downloads");
String[] listedFiles = file.list((dir, name) -> name.endsWith(".pdf"));
Stream.of(listedFiles)
		.filter(s -> s.length() > 3)
        .sorted((String s1, String s2) -> {return  s1.length() - s2.length();})
        .map((String s) -> {return s.toUpperCase();})
        .forEach(System.out::println);
```

- filter() accepts a `Predicate<T>`
```java
Predicate<String> nameLength = (String s) -> { return s.length() > 3 };

// Shorter version
// String s : String type is inferred from Predicate<String>
// A single argument does not need to be wrapped in ()
// A single returning single value without lambda body does not need a return statement
Predicate<String> nameLength = s -> s.length() > 3;
```

- Comparator argument types are inferred from the type parameter of `Stream<T>` which is `String`

```java
(String s1, String s2) -> {return  s1.length() - s2.length();}

// Can be written as
(s1, s2) -> {return s1.length() - s2.length();}

// When returning a single value, { return ... } can be omitted
(s1, s2) -> s1.length() - s2.length()


// Lambda reference
Comparator<String> myComparator = (s1, s2) -> s1.length() - s2.length();

// Pass the lamba as an argument to the sort() method
list.sort(myComparator)
```

- `Function<String, String>` used by the map() method

```java
Function<String, String> upper = s -> s.toUpperCase();

// Method reference
// When the provided argument's method is called only
// Execute toUpperCase() method on the provided argument
Function<String, String> upper = String::toUpperCase
```

- `Consumer<String>` used by the foreach() method, which is a **terminal** operation

```java
Consumer<String> print = s -> {
	System.out.println(s);
};
```

# Returning functional interfaces

- A method can have an interface as a return type, which can be constructed as a lambda

- Example: `java.util.Comparator#comparingInt`

- Creating a predicate

```java
public Predicate<String> getCondition(int size) {
	return String str -> str.length() > size;
}

Predicate<String> condition1 = getCondition(3);
Predicate<String> condition2 = getCondition(10);

boolean test1 = condition1.test("Hello World");
boolean test2 = condition2.test("Hello World");
```

# Closures in Java

```java
interface IntSupplier extends Supplier<Integer> {

}

IntSupplier[] amazing = new IntSupplier[10];
for (int i = 0; i < 10; i++) {
    int value = i;
    amazing[i] = () -> value;
}

System.out.println(i);
System.out.println(value);

for (int i = 0; i < 10; i++) {
    System.out.println(amazing[i].get());
}
```

# Java Streams

- Define **what** needs to be done on collections and not exactly **how**
- Java 8 introduced the **default method** `stream()` available on all collections

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
numbers.add(3);
numbers.add(4);

Stream<Integer> streamOfNumbers = numbers.stream();
```

# Basic functional programming methods

Given a list, or list-like structure, there are 3 main useful methods:

- filter()
Applied to each element in the list, leaving only those that match a certain condition

```java
numbers.stream().filter(i -> i % 2 == 0).forEach(System.out::println);
```

- map()
Applied to each element in the list, converting it to a different object (maybe also of a different type)

```java
numbers.stream().map(i -> i * 2).forEach(System.out::println);

numbers.stream().filter(i -> i % 2 == 0).map(i -> i * 2).forEach(System.out::println);

numbers.stream().filter(i -> i % 2 == 0).map(i -> i * 2).map(i -> "Number = " + i).forEach(System.out::println);
```

- reduce()
Given an initial value, apply a logic to each element in the list and produce a final value

```java
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
```

- The result of filter() and map() is also a Stream because these are **intermediate** operations.
- The result of reduce() is not a Stream because it is a **terminal** operation.
- Other terminal operations:
	- count()
	- forEach()
	- collect()

- Stream pipeline: Original collection is not modified

```
Original Collection -> Stream -> Stream -> Stream -> New Collection
```

- Streams work with objects, except:
	- IntStream
	- DoubleStream

# stream() and parallelStream()

Run the program using:
	- stream()
	- parallelStream()

```java
public static void main(String[] args) {
    long N = 10_000_000;
    List<Long> listOfNumbers = new ArrayList<>();
    for (long i = 0; i < N; i++) listOfNumbers.add(i);

    long totalTime = 0;
    int times = 100;

    for (int i = 0; i < times; i++) {
        long now = System.currentTimeMillis();
        listOfNumbers.stream().reduce(Long::sum).get();	// TODO use parallelStream()
        totalTime += System.currentTimeMillis() - now;
    }

    System.out.println("Average runtime: " + (totalTime / (double) times) + " ms");
}
```

# Homework 3

**Deadline: Thursday 24 November 2022, 6:30 pm**

Go back to your solution of homework 1:

Read a large text line by line and count the number of lines and words.

Use streams to write as consice code as you can. Do not modify your old solution. Instead, add a new class that contains your new code and publish it as a new Maven version (core).

Update the dependency of service to use the new version. You should not change any source code in the service module, just update the dependency version to the new published version (e.g. 1.1.0).

Use the file provided in the repository.

Compare your new solution with the solution during homework 1.

Sample output (using Unix wc tool) to verify the correctness of your program:

```
cat input-file.txt | wc -wl
      16     704
```
